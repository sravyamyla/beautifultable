{% extends "base.html" %}
{% block title %}Index{% endblock %}
{% block content %}

<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <!-- meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <title>OOP Principles</title>
    <style>
        body {
            background-color: #e3f2fd;
            font-family: Helvetica, sans-serif;
        }
        .footer {
            position: relative;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 40px;
            background-color: grey;
            color: white;
            text-align: center;
            line-height: 2.5;
        }
    </style>


</head>
<body>
<div class="container-fluid">
    </br>
    <h2><b>What is S.O.L.I.D</b></h2>
    <p>SOLID is an acronym for the first five principles of the article Principles of Object-Oriented Design by Robert C. Martin. Applying these principles helps to develop maintainable and extensible code. They also help to catch code smells, refactor code easily, and practice a good agile development.</p>
    <p> S stands for SRP - Single Responsibility Principle </br>
        O stands for OCP - Open-Closed Principle </br>
        L stands for LSP - Liskov Substitution Principle </br>
        I stands for ISP - Interface Segregation Principle </br>
        D stands for DIP - Dependency Inversion Principle</p>
    </br>
    <div class="text-center">
        <img class="img-responsive" src="images/solid.png" alt="Act" width="700" height="300">
        <p>Fig. 1</p>
    </div>

    <h3><b>Single Responsibility Principle</b></h3>
    <p>This principle means that an entity should do only one thing. So single responsibility denotes some work in isolation. If we have a software entity that performs some calculations the only reason to change it is if these calculations need to change, Single Responsibility Principle requires that a class should have only one job. So if a class has more than one responsibility, it becomes coupled. A change to one responsibility results to modification of the other responsibility.<br/></p>
    <p>We have a User class which is responsible for both the user properties and user database management. If the application changes in a way that it affect database management functions. The classes that make use of User properties will have to be touched and recompiled to compensate for the new changes. It’s like a domino effect, touch one card it affects all other cards in line.</p>
    <div class="text-center">
        <img class="img-responsive" src="images/SRP.png" alt="Act" width="700" height="300">
        <p>Fig. 1.1</p>
    </div>
    </br>

    <h3><b>Open Closed Principle</b></h3>
    <p>If you are not modifying the existing code, you know you aren’t breaking any of it. All the new functionality is contained in the newly added functions or classes.
        The hardest part about this principle is recognizing when it can be applied before you begin coding. Here are a couple of guidelines to help you recognize when open/closed may be applicable.</br></p>
    <ol>
        <li>When you have algorithms that perform a calculation (cost, tax, game score, etc.): the algorithm will likely change over time. </li>
        <li>When you have data coming or going from the system: the endpoint (file, database, another system) is likely to change. So is the actual format of the data. </li>
    </ol>
    <div class="text-center">
        <img class="img-responsive" src="images/OCP.png" alt="Act" width="700" height="300">
        <p>Fig. 1.2</p>
    </div>
    </br>

    <h3><b>Liskov Substitution Principle</b></h3>
    <p> What this principle means is that objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program. So if you pass a subclass of an abstraction you need to make sure you don’t alter any behavior or state semantics of the parent abstraction.</br></p>

    <div class="text-center">
        <img class="img-responsive" src="images/LSP.png" alt="Act" width="700" height="300">
        <p>Fig. 1.3</p>
    </div>
    </br>
    <h3><b>Interface Segregation Principle</b></h3>
    <p>This principle is the first principle that applies to Interfaces instead of classes in SOLID and it is similar to the single responsibility principle. It states that “do not force any client to implement an interface which is irrelevant to them“. Here your main goal is to focus on avoiding fat interface and give preference to many small client-specific interfaces. You should prefer many client interfaces rather than one general interface and each interface should have a specific responsibility.</p>
    <p>Suppose if you enter a restaurant you are pure vegetarian. The waiter in that restaurant gave you the menu card which includes vegetarian items, non-vegetarian items, drinks, and sweets. In this case, as a customer, you should have a menu card which includes only vegetarian items, not everything which you don’t eat in your food. Here the menu should be different for different types of customers. The common or general menu card for everyone can be divided into multiple cards instead of just one. Using this principle helps in reducing the side effects and frequency of required changes.</p>
    </br>
    <div class="text-center">
        <img class="img-responsive" src="images/ISP.png" alt="Act" width="700" height="300">
        <p>Fig. 1.4</p>
    </div>
    </br>

    <P>Both images above are formed from the same number of pixels, but while one looks like a bear, the other one looks more like a shocked square. It is not a difference of quantity, but one of granularity. It is easier to compose something with smaller pieces.
        The same logic can be applied to writing good, resilient code. Client code shouldn’t be forced to implement methods that it doesn’t use. This is the Interface Segregation Principle as defined by Robert C. Martin.</P>
    <h4><b>Dependency Inversion Principle</b></h4>
    <p>This principle states that High-level modules which provide complex logic should be easily reusable and unaffected by changes in low-level modules, which provide utility features. To achieve that you need to introduce an abstraction that decouples the high level and low level modules from each other.</p>
    <p> Based on this idea, Robert C. Martin’s definition of the Dependency Inversion Principle consists of two parts: </br></p>
    <li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li>
    <li>Abstractions should not depend on details. Details should depend on abstractions.</li>
    </br>
    <div class="text-center">
        <img class="img-responsive" src="images/DIP.png" alt="Act" width="700" height="300">
        <p>Fig. 1.5</p>
    </div>

    <p>An important detail of this definition is, that high-level and low-level modules depend on the abstraction. The design principle does not just change the direction of the dependency, as you might have expected when you read its name for the first time. It splits the dependency between the high level and low level modules by introducing an abstraction between them. So in the end, you get two dependencies: </br></p>
    <li>High level module depends on the abstraction.</li>
    <li>Low level depends on the same abstraction.</li>
</div>
</br>


</body>
</html>

{% endblock %}

